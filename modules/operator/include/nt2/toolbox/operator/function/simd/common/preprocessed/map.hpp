namespace nt2 { namespace meta { template<class Func , class A0 , class X> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<Func> , nt2::meta::simd_< unspecified_<A0>, X >) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_< unspecified_<A0>, X > const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<Func> , nt2::meta::simd_< unspecified_<A0>, X > ) , tag::cpu_ > that; return that; } template< class Func , class A0 , class X , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<Func> , nt2::meta::simd_< unspecified_<A0>, X > ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, X> result_type; inline result_type operator()(Func const& f, A0 const& a0) { NT2_ALIGNED_TYPE(stype) tmp[meta::cardinal_of<A0>::value]; for(int i = 0; i != meta::cardinal_of<A0>::value; ++i) tmp[i] = details::maybe_genmask<stype>(f(a0[i])); return load<result_type>(&tmp[0], 0); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class X> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<Func> , nt2::meta::simd_< unspecified_<A0>, X > , nt2::meta::simd_< unspecified_<A1>, X >) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_< unspecified_<A0>, X > const& , nt2::meta::simd_< unspecified_<A1>, X > const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<Func> , nt2::meta::simd_< unspecified_<A0>, X > , nt2::meta::simd_< unspecified_<A1>, X > ) , tag::cpu_ > that; return that; } template< class Func , class A0 , class A1 , class X , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<Func> , nt2::meta::simd_< unspecified_<A0>, X > , nt2::meta::simd_< unspecified_<A1>, X > ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, X> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1) { NT2_ALIGNED_TYPE(stype) tmp[meta::cardinal_of<A0>::value]; for(int i = 0; i != meta::cardinal_of<A0>::value; ++i) tmp[i] = details::maybe_genmask<stype>(f(a0[i] , a1[i])); return load<result_type>(&tmp[0], 0); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class A2 , class X> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<Func> , nt2::meta::simd_< unspecified_<A0>, X > , nt2::meta::simd_< unspecified_<A1>, X > , nt2::meta::simd_< unspecified_<A2>, X >) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_< unspecified_<A0>, X > const& , nt2::meta::simd_< unspecified_<A1>, X > const& , nt2::meta::simd_< unspecified_<A2>, X > const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<Func> , nt2::meta::simd_< unspecified_<A0>, X > , nt2::meta::simd_< unspecified_<A1>, X > , nt2::meta::simd_< unspecified_<A2>, X > ) , tag::cpu_ > that; return that; } template< class Func , class A0 , class A1 , class A2 , class X , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<Func> , nt2::meta::simd_< unspecified_<A0>, X > , nt2::meta::simd_< unspecified_<A1>, X > , nt2::meta::simd_< unspecified_<A2>, X > ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, X> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2) { NT2_ALIGNED_TYPE(stype) tmp[meta::cardinal_of<A0>::value]; for(int i = 0; i != meta::cardinal_of<A0>::value; ++i) tmp[i] = details::maybe_genmask<stype>(f(a0[i] , a1[i] , a2[i])); return load<result_type>(&tmp[0], 0); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3 , class X> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<Func> , nt2::meta::simd_< unspecified_<A0>, X > , nt2::meta::simd_< unspecified_<A1>, X > , nt2::meta::simd_< unspecified_<A2>, X > , nt2::meta::simd_< unspecified_<A3>, X >) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_< unspecified_<A0>, X > const& , nt2::meta::simd_< unspecified_<A1>, X > const& , nt2::meta::simd_< unspecified_<A2>, X > const& , nt2::meta::simd_< unspecified_<A3>, X > const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<Func> , nt2::meta::simd_< unspecified_<A0>, X > , nt2::meta::simd_< unspecified_<A1>, X > , nt2::meta::simd_< unspecified_<A2>, X > , nt2::meta::simd_< unspecified_<A3>, X > ) , tag::cpu_ > that; return that; } template< class Func , class A0 , class A1 , class A2 , class A3 , class X , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<Func> , nt2::meta::simd_< unspecified_<A0>, X > , nt2::meta::simd_< unspecified_<A1>, X > , nt2::meta::simd_< unspecified_<A2>, X > , nt2::meta::simd_< unspecified_<A3>, X > ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, X> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3) { NT2_ALIGNED_TYPE(stype) tmp[meta::cardinal_of<A0>::value]; for(int i = 0; i != meta::cardinal_of<A0>::value; ++i) tmp[i] = details::maybe_genmask<stype>(f(a0[i] , a1[i] , a2[i] , a3[i])); return load<result_type>(&tmp[0], 0); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class X> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<Func> , nt2::meta::simd_< unspecified_<A0>, X > , nt2::meta::simd_< unspecified_<A1>, X > , nt2::meta::simd_< unspecified_<A2>, X > , nt2::meta::simd_< unspecified_<A3>, X > , nt2::meta::simd_< unspecified_<A4>, X >) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_< unspecified_<A0>, X > const& , nt2::meta::simd_< unspecified_<A1>, X > const& , nt2::meta::simd_< unspecified_<A2>, X > const& , nt2::meta::simd_< unspecified_<A3>, X > const& , nt2::meta::simd_< unspecified_<A4>, X > const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<Func> , nt2::meta::simd_< unspecified_<A0>, X > , nt2::meta::simd_< unspecified_<A1>, X > , nt2::meta::simd_< unspecified_<A2>, X > , nt2::meta::simd_< unspecified_<A3>, X > , nt2::meta::simd_< unspecified_<A4>, X > ) , tag::cpu_ > that; return that; } template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class X , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<Func> , nt2::meta::simd_< unspecified_<A0>, X > , nt2::meta::simd_< unspecified_<A1>, X > , nt2::meta::simd_< unspecified_<A2>, X > , nt2::meta::simd_< unspecified_<A3>, X > , nt2::meta::simd_< unspecified_<A4>, X > ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, X> result_type; inline result_type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4) { NT2_ALIGNED_TYPE(stype) tmp[meta::cardinal_of<A0>::value]; for(int i = 0; i != meta::cardinal_of<A0>::value; ++i) tmp[i] = details::maybe_genmask<stype>(f(a0[i] , a1[i] , a2[i] , a3[i] , a4[i])); return load<result_type>(&tmp[0], 0); } }; } }
