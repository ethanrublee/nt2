namespace nt2 { namespace meta { template<class A0 , class A1> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints64_<A1>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints64_<A1>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints64_<A1>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints64_<A1>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints64_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints64_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints64_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints64_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2 , class A3> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints64_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints64_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints64_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints64_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2 , class A3 , class A4> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints64_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints64_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints64_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints64_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1]))); } }; } }
namespace nt2 { namespace meta { template<class A0 , class A1> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< double_<A1>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< double_<A1>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< double_<A1>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< double_<A1>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< double_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< double_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< double_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< double_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2 , class A3> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< double_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< double_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< double_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< double_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2 , class A3 , class A4> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< double_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< double_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< double_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< double_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1]))); } }; } }
namespace nt2 { namespace meta { template<class A0 , class A1> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< float_<A1>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< float_<A1>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< float_<A1>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< float_<A1>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< float_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< float_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< float_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< float_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2 , class A3> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< float_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< float_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< float_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< float_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2 , class A3 , class A4> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< float_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< float_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< float_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< float_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2] , a4[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3] , a4[ 3]))); } }; } }
namespace nt2 { namespace meta { template<class A0 , class A1> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints32_<A1>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints32_<A1>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints32_<A1>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints32_<A1>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints32_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints32_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints32_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints32_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2 , class A3> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints32_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints32_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints32_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints32_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2 , class A3 , class A4> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints32_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints32_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints32_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints32_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2] , a4[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3] , a4[ 3]))); } }; } }
namespace nt2 { namespace meta { template<class A0 , class A1> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints16_<A1>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints16_<A1>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints16_<A1>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints16_<A1>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints16_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints16_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints16_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints16_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2 , class A3> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints16_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints16_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints16_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints16_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4] , a3[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5] , a3[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6] , a3[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7] , a3[ 7]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2 , class A3 , class A4> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints16_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints16_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints16_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints16_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2] , a4[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3] , a4[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4] , a3[ 4] , a4[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5] , a3[ 5] , a4[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6] , a3[ 6] , a4[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7] , a3[ 7] , a4[ 7]))); } }; } }
namespace nt2 { namespace meta { template<class A0 , class A1> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints8_<A1>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints8_<A1>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints8_<A1>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints8_<A1>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7])) , details::maybe_genmask<stype>(a0(a1[ 8])) , details::maybe_genmask<stype>(a0(a1[ 9])) , details::maybe_genmask<stype>(a0(a1[ 10])) , details::maybe_genmask<stype>(a0(a1[ 11])) , details::maybe_genmask<stype>(a0(a1[ 12])) , details::maybe_genmask<stype>(a0(a1[ 13])) , details::maybe_genmask<stype>(a0(a1[ 14])) , details::maybe_genmask<stype>(a0(a1[ 15]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints8_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints8_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints8_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints8_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7])) , details::maybe_genmask<stype>(a0(a1[ 8] , a2[ 8])) , details::maybe_genmask<stype>(a0(a1[ 9] , a2[ 9])) , details::maybe_genmask<stype>(a0(a1[ 10] , a2[ 10])) , details::maybe_genmask<stype>(a0(a1[ 11] , a2[ 11])) , details::maybe_genmask<stype>(a0(a1[ 12] , a2[ 12])) , details::maybe_genmask<stype>(a0(a1[ 13] , a2[ 13])) , details::maybe_genmask<stype>(a0(a1[ 14] , a2[ 14])) , details::maybe_genmask<stype>(a0(a1[ 15] , a2[ 15]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2 , class A3> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints8_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints8_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints8_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints8_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4] , a3[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5] , a3[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6] , a3[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7] , a3[ 7])) , details::maybe_genmask<stype>(a0(a1[ 8] , a2[ 8] , a3[ 8])) , details::maybe_genmask<stype>(a0(a1[ 9] , a2[ 9] , a3[ 9])) , details::maybe_genmask<stype>(a0(a1[ 10] , a2[ 10] , a3[ 10])) , details::maybe_genmask<stype>(a0(a1[ 11] , a2[ 11] , a3[ 11])) , details::maybe_genmask<stype>(a0(a1[ 12] , a2[ 12] , a3[ 12])) , details::maybe_genmask<stype>(a0(a1[ 13] , a2[ 13] , a3[ 13])) , details::maybe_genmask<stype>(a0(a1[ 14] , a2[ 14] , a3[ 14])) , details::maybe_genmask<stype>(a0(a1[ 15] , a2[ 15] , a3[ 15]))); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2 , class A3 , class A4> inline nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints8_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_>) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<A0> const& , nt2::meta::simd_< ints8_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> const& , adl_helper = adl_helper() ) { nt2::meta:: implement< tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints8_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> ) , tag::cpu_ > that; return that; } template< class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < tag::map_(nt2::meta::unspecified_<A0> , nt2::meta::simd_< ints8_<A1>,tag::sse_> , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> , nt2::meta::simd_< arithmetic_<A4>,tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename meta:: result_of< typename meta:: strip<A0>::type const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef simd::native<stype, tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { return make<result_type>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2] , a4[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3] , a4[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4] , a3[ 4] , a4[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5] , a3[ 5] , a4[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6] , a3[ 6] , a4[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7] , a3[ 7] , a4[ 7])) , details::maybe_genmask<stype>(a0(a1[ 8] , a2[ 8] , a3[ 8] , a4[ 8])) , details::maybe_genmask<stype>(a0(a1[ 9] , a2[ 9] , a3[ 9] , a4[ 9])) , details::maybe_genmask<stype>(a0(a1[ 10] , a2[ 10] , a3[ 10] , a4[ 10])) , details::maybe_genmask<stype>(a0(a1[ 11] , a2[ 11] , a3[ 11] , a4[ 11])) , details::maybe_genmask<stype>(a0(a1[ 12] , a2[ 12] , a3[ 12] , a4[ 12])) , details::maybe_genmask<stype>(a0(a1[ 13] , a2[ 13] , a3[ 13] , a4[ 13])) , details::maybe_genmask<stype>(a0(a1[ 14] , a2[ 14] , a3[ 14] , a4[ 14])) , details::maybe_genmask<stype>(a0(a1[ 15] , a2[ 15] , a3[ 15] , a4[ 15]))); } }; } }
