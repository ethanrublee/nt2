////////////////////////////////////////////////////////////////////////////////
// Register all tag and extension agnostic call for common code sharing
////////////////////////////////////////////////////////////////////////////////
namespace nt2 { namespace meta
{
  template<class A0 , class Tag> inline nt2::meta:: implement< Tag(nt2::meta::generic_< unspecified_<A0> >) , tag::cpu_ > dispatching( Tag const&, tag::cpu_ const& , nt2::meta::generic_< unspecified_<A0> > const& , adl_helper = adl_helper() ) { nt2::meta:: implement< Tag(nt2::meta::generic_< unspecified_<A0> > ) , tag::cpu_ > that; return that; } template<class A0 , class Tag> inline nt2::meta:: implement< Tag(nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> >) , tag::cpu_ > dispatching( Tag const&, tag::cpu_ const& , nt2::meta::generic_< unspecified_<A0> > const& , nt2::meta::generic_< unspecified_<A0> > const& , adl_helper = adl_helper() ) { nt2::meta:: implement< Tag(nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > ) , tag::cpu_ > that; return that; } template<class A0 , class Tag> inline nt2::meta:: implement< Tag(nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> >) , tag::cpu_ > dispatching( Tag const&, tag::cpu_ const& , nt2::meta::generic_< unspecified_<A0> > const& , nt2::meta::generic_< unspecified_<A0> > const& , nt2::meta::generic_< unspecified_<A0> > const& , adl_helper = adl_helper() ) { nt2::meta:: implement< Tag(nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > ) , tag::cpu_ > that; return that; } template<class A0 , class Tag> inline nt2::meta:: implement< Tag(nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> >) , tag::cpu_ > dispatching( Tag const&, tag::cpu_ const& , nt2::meta::generic_< unspecified_<A0> > const& , nt2::meta::generic_< unspecified_<A0> > const& , nt2::meta::generic_< unspecified_<A0> > const& , nt2::meta::generic_< unspecified_<A0> > const& , adl_helper = adl_helper() ) { nt2::meta:: implement< Tag(nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > ) , tag::cpu_ > that; return that; } template<class A0 , class Tag> inline nt2::meta:: implement< Tag(nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> >) , tag::cpu_ > dispatching( Tag const&, tag::cpu_ const& , nt2::meta::generic_< unspecified_<A0> > const& , nt2::meta::generic_< unspecified_<A0> > const& , nt2::meta::generic_< unspecified_<A0> > const& , nt2::meta::generic_< unspecified_<A0> > const& , nt2::meta::generic_< unspecified_<A0> > const& , adl_helper = adl_helper() ) { nt2::meta:: implement< Tag(nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > , nt2::meta::generic_< unspecified_<A0> > ) , tag::cpu_ > that; return that; }
} }
////////////////////////////////////////////////////////////////////////////////
// Generate all the common map calls over Tag using nt2::map
////////////////////////////////////////////////////////////////////////////////
namespace nt2 { namespace meta { template<class A0,class Tag, class Dummy> struct implement<Tag( generic_< unspecified_<A0> > ), tag::cpu_, Dummy> { typedef typename meta::call<tag::map_ ( functor<Tag> , A0 )>::type result_type; inline result_type operator()( A0 const& a0 ) const { return nt2::map( functor<Tag>(), a0); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1,class Tag, class Dummy> struct implement<Tag( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > ), tag::cpu_, Dummy> { typedef typename meta::call<tag::map_ ( functor<Tag> , A0 , A1 )>::type result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 ) const { return nt2::map( functor<Tag>(), a0 , a1); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2,class Tag, class Dummy> struct implement<Tag( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > ), tag::cpu_, Dummy> { typedef typename meta::call<tag::map_ ( functor<Tag> , A0 , A1 , A2 )>::type result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { return nt2::map( functor<Tag>(), a0 , a1 , a2); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2 , class A3,class Tag, class Dummy> struct implement<Tag( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > ), tag::cpu_, Dummy> { typedef typename meta::call<tag::map_ ( functor<Tag> , A0 , A1 , A2 , A3 )>::type result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { return nt2::map( functor<Tag>(), a0 , a1 , a2 , a3); } }; } } namespace nt2 { namespace meta { template<class A0 , class A1 , class A2 , class A3 , class A4,class Tag, class Dummy> struct implement<Tag( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > , generic_< unspecified_<A4> > ), tag::cpu_, Dummy> { typedef typename meta::call<tag::map_ ( functor<Tag> , A0 , A1 , A2 , A3 , A4 )>::type result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { return nt2::map( functor<Tag>(), a0 , a1 , a2 , a3 , a4); } }; } }
